{% extends "base.html" %}

{% block title %}Gunplay - {{ app_title }}{% endblock %}

{% block content %}
<section class="panel">
  <h2>Gunplay Performance</h2>
  <p class="muted">Accuracy and kill stats by weapon type (Ranked matches only)</p>
</section>

<section class="panel">
  <h2>Overall Gunplay Stats</h2>
  <div class="table-wrap">
    <table class="data-table" data-table="weapons">
      <thead>
        <tr>
          <th>Player</th>
          <th title="Total shots fired">Fired</th>
          <th title="Total shots that hit">Landed</th>
          <th title="Overall accuracy percentage">Accuracy</th>
          <th title="Total headshot kills">Headshots</th>
          <th title="Headshot percentage of kills">HS %</th>
          <th title="Melee kills">Melee</th>
          <th title="Grenade kills">Grenades</th>
          <th title="Power weapon kills">Power</th>
        </tr>
      </thead>
      <tbody>
        {% if weapon_rows %}
        {% for row in weapon_rows %}
        <tr>
          <td><a href="/player/{{ row.player }}" class="player-name {{ row.player|player_class }}"><strong>{{ row.player }}</strong></a></td>
          <td>{{ row.shots_fired }}</td>
          <td>{{ row.shots_hit }}</td>
          <td class="{{ row.accuracy_heat }}">{{ row.accuracy }}</td>
          <td class="{{ row.headshots_heat }}">{{ row.headshots }}</td>
          <td class="{{ row.hs_pct_heat }}">{{ row.hs_pct }}</td>
          <td class="{{ row.melee_heat }}">{{ row.melee }}</td>
          <td class="{{ row.grenades_heat }}">{{ row.grenades }}</td>
          <td class="{{ row.power_heat }}">{{ row.power }}</td>
        </tr>
        {% endfor %}
        {% else %}
        <tr>
          <td colspan="9" class="empty">No weapon data available</td>
        </tr>
        {% endif %}
      </tbody>
    </table>
  </div>
</section>

<section class="panel">
  <h2>Accuracy Trend (Last 30 Days)</h2>
  <div class="chart-container">
    <canvas id="accuracyChart"></canvas>
  </div>
</section>
{% endblock %}

{% block scripts %}
<script>
const chartColors = ['#3dbfb8', '#ff7a3d', '#ffd700', '#86efac', '#fca5a5', '#c4b5fd'];
const playerColors = [
  { key: 'zaidster', color: '#228b22' },
  { key: '0cty', color: '#ffd700' },
  { key: 'octy', color: '#ffd700' },
  { key: 'viper', color: '#4169e1' },
  { key: 'jordo', color: '#c0c0c0' },
  { key: 'p1n1', color: '#dc3545' },
  { key: 'pini', color: '#dc3545' }
];

const hexToRgb = (hex) => {
  const clean = hex.replace('#', '').trim();
  if (clean.length !== 6) return null;
  return {
    r: parseInt(clean.slice(0, 2), 16),
    g: parseInt(clean.slice(2, 4), 16),
    b: parseInt(clean.slice(4, 6), 16)
  };
};

const withAlpha = (hex, alpha) => {
  const rgb = hexToRgb(hex);
  return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})` : hex;
};

const getPlayerColor = (player, fallback) => {
  const name = String(player || '').toLowerCase();
  const match = playerColors.find(entry => name.includes(entry.key));
  return match ? match.color : fallback;
};

const sortTrendData = (data) => data.slice().sort((a, b) => a.date.localeCompare(b.date));
const buildTrendLabels = (trends) => {
  const dates = new Set();
  Object.values(trends || {}).forEach(series => {
    series.forEach(point => dates.add(point.date));
  });
  return Array.from(dates).sort((a, b) => a.localeCompare(b));
};
const getTrendRange = (trends, valueKey, padding = 0.1, bounds = null) => {
  const values = [];
  Object.values(trends || {}).forEach(series => {
    series.forEach(point => {
      const value = Number(point[valueKey]);
      if (Number.isFinite(value)) {
        values.push(value);
      }
    });
  });
  if (!values.length) {
    return {};
  }
  let min = Math.min(...values);
  let max = Math.max(...values);
  if (min === max) {
    min -= 1;
    max += 1;
  }
  const range = max - min;
  const pad = range * padding;
  min -= pad;
  max += pad;
  if (bounds) {
    if (typeof bounds.min === 'number') {
      min = Math.max(min, bounds.min);
    }
    if (typeof bounds.max === 'number') {
      max = Math.min(max, bounds.max);
    }
  }
  return { min, max };
};

const accuracyData = {{ accuracy_trend|tojson|safe }};
if (accuracyData && Object.keys(accuracyData).length > 0) {
  const ctx = document.getElementById('accuracyChart').getContext('2d');
  const labels = buildTrendLabels(accuracyData);
  const datasets = Object.entries(accuracyData).map(([player, data], index) => ({
    label: player,
    data: sortTrendData(data).map(d => ({ x: d.date, y: d.accuracy })),
    borderColor: getPlayerColor(player, chartColors[index % chartColors.length]),
    backgroundColor: withAlpha(getPlayerColor(player, chartColors[index % chartColors.length]), 0.2),
    tension: 0.2,
    borderWidth: 2,
    pointRadius: 0,
    pointHoverRadius: 3,
    spanGaps: true
  }));
  
  const accuracyRange = getTrendRange(accuracyData, 'accuracy', 0.12, { min: 0, max: 100 });
  new Chart(ctx, {
    type: 'line',
    data: { labels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { 
          labels: { color: '#e8dfd3' }
        }
      },
      scales: {
        x: {
          type: 'category',
          grid: { color: 'rgba(255,255,255,0.05)' },
          ticks: { color: '#9a8f82' }
        },
        y: {
          grid: { color: 'rgba(255,255,255,0.05)' },
          ticks: { color: '#9a8f82' },
          min: accuracyRange.min,
          max: accuracyRange.max
        }
      }
    }
  });
}
</script>
{% endblock %}
